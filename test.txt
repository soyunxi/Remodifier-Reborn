public class ProcessorScreen extends AbstractContainerScreen<ProcessorContainer> {

    private final ResourceLocation GUI = new ResourceLocation(Tutorial2Block.MODID, "textures/gui/processor.png");

    // GUI区域在PNG文件内的坐标
    private static final int GUI_X_TEXTURE = 0;      // GUI在纹理中的X起始位置
    private static final int GUI_Y_TEXTURE = 0;      // GUI在纹理中的Y起始位置
    private static final int GUI_WIDTH = 176;        // GUI宽度
    private static final int GUI_HEIGHT = 166;       // GUI高度

    // 按钮纹理坐标 - 四种状态
    private static final int BUTTON_X_TEXTURE = 176;           // 按钮在纹理中的X起始位置
    private static final int BUTTON_Y_NORMAL = 0;              // 正常状态的按钮
    private static final int BUTTON_Y_HOVER = 18;              // 鼠标悬浮时的按钮
    private static final int BUTTON_Y_DISABLED = 36;           // 不可用状态的按钮
    private static final int BUTTON_Y_DISABLED_HOVER = 54;     // 不可用且鼠标悬浮时的按钮
    private static final int BUTTON_WIDTH = 18;                // 按钮宽度
    private static final int BUTTON_HEIGHT = 18;               // 按钮高度

    // 提示图标纹理坐标
    private static final int ICON_X_TEXTURE = 176;           // 图标在纹理中的X起始位置
    private static final int ICON_Y_TEXTURE = 72;            // 图标在纹理中的Y起始位置
    private static final int ICON_WIDTH = 16;                // 图标宽度
    private static final int ICON_HEIGHT = 16;               // 图标高度

    // GUI中的位置
    private static final int BUTTON_X_POS = 120;             // 按钮在GUI中的X位置
    private static final int BUTTON_Y_POS = 35;              // 按钮在GUI中的Y位置
    private static final int ICON_X_POS = 30;                // 图标在GUI中的X位置
    private static final int ICON_Y_POS = 35;                // 图标在GUI中的Y位置

    // 创建按钮实例
    private Button processorButton;

    public ProcessorScreen(ProcessorContainer container, Inventory inventory, Component title) {
        super(container, inventory, title);
        this.imageWidth = GUI_WIDTH;
        this.imageHeight = GUI_HEIGHT;
        this.inventoryLabelY = this.imageHeight - 110;
    }

    @Override
    protected void init() {
        super.init();

        // 计算GUI的相对位置
        int relX = (this.width - this.imageWidth) / 2;
        int relY = (this.height - this.imageHeight) / 2;

        // 创建自定义按钮
        this.processorButton = new Button(
            relX + BUTTON_X_POS,
            relY + BUTTON_Y_POS,
            BUTTON_WIDTH,
            BUTTON_HEIGHT,
            Component.literal(""),
            this::onButtonPress,
            (button, graphics, mouseX, mouseY) -> {
                if (canProcess()) {
                    graphics.renderTooltip(this.font, Component.translatable("gui." + Tutorial2Block.MODID + ".processor_button"), mouseX, mouseY);
                } else {
                    graphics.renderTooltip(this.font, Component.translatable("gui." + Tutorial2Block.MODID + ".missing_item"), mouseX, mouseY);
                }
            }
        ) {
            @Override
            public void render(GuiGraphics graphics, int mouseX, int mouseY, float partialTicks) {
                // 不使用默认渲染，只检测鼠标是否悬浮
                this.isHovered = mouseX >= this.getX() && mouseY >= this.getY() &&
                                mouseX < this.getX() + this.width && mouseY < this.getY() + this.height;
            }

            @Override
            public boolean mouseClicked(double mouseX, double mouseY, int button) {
                if (this.isHovered) {
                    if (canProcess()) {
                        return super.mouseClicked(mouseX, mouseY, button);
                    }
                }
                return false;
            }
        };

        this.addRenderableWidget(processorButton);
    }

    // 判断是否可以处理的方法
    private boolean canProcess() {
        return this.menu.getBlockEntity().hasRequiredItem();
    }

    // 按钮点击事件处理
    private void onButtonPress(Button button) {
        // 发送网络包给服务器开始处理
        NetworkHandler.sendToServer(new ProcessorButtonPacket(menu.getBlockEntity().getBlockPos()));
    }

    @Override
    public void render(GuiGraphics graphics, int mouseX, int mouseY, float partialTicks) {
        this.renderBackground(graphics);
        super.render(graphics, mouseX, mouseY, partialTicks);
        this.renderTooltip(graphics, mouseX, mouseY);
    }

    @Override
    protected void renderBg(GuiGraphics graphics, float partialTicks, int mouseX, int mouseY) {
        int relX = (this.width - this.imageWidth) / 2;
        int relY = (this.height - this.imageHeight) / 2;

        // 渲染主GUI背景
        graphics.blit(GUI, relX, relY, GUI_X_TEXTURE, GUI_Y_TEXTURE, this.imageWidth, this.imageHeight);

        // 渲染按钮
        renderButton(graphics, mouseX, mouseY);

        // 如果需要，渲染提示图标
        if (!canProcess()) {
            renderIcon(graphics);
        }
    }

    // 渲染按钮方法
    private void renderButton(GuiGraphics graphics, int mouseX, int mouseY) {
        int relX = (this.width - this.imageWidth) / 2;
        int relY = (this.height - this.imageHeight) / 2;

        boolean canProcess = canProcess();
        boolean isHovering = mouseX >= relX + BUTTON_X_POS && mouseX < relX + BUTTON_X_POS + BUTTON_WIDTH &&
                            mouseY >= relY + BUTTON_Y_POS && mouseY < relY + BUTTON_Y_POS + BUTTON_HEIGHT;

        // 选择按钮纹理Y坐标
        int yTexture;
        if (canProcess) {
            if (isHovering) {
                yTexture = BUTTON_Y_HOVER;      // 可用且鼠标悬浮
            } else {
                yTexture = BUTTON_Y_NORMAL;     // 可用正常状态
            }
        } else {
            if (isHovering) {
                yTexture = BUTTON_Y_DISABLED_HOVER;  // 不可用且鼠标悬浮
            } else {
                yTexture = BUTTON_Y_DISABLED;       // 不可用正常状态
            }
        }

        // 渲染按钮
        graphics.blit(GUI, relX + BUTTON_X_POS, relY + BUTTON_Y_POS, BUTTON_X_TEXTURE, yTexture, BUTTON_WIDTH, BUTTON_HEIGHT);
    }

    // 渲染提示图标方法
    private void renderIcon(GuiGraphics graphics) {
        int relX = (this.width - this.imageWidth) / 2;
        int relY = (this.height - this.imageHeight) / 2;

        // 渲染缺少物品的提示图标
        graphics.blit(GUI, relX + ICON_X_POS, relY + ICON_Y_POS, ICON_X_TEXTURE, ICON_Y_TEXTURE, ICON_WIDTH, ICON_HEIGHT);
    }
}